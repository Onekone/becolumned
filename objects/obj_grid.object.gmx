<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite8</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>gameMode = gamemode_normal;

keepScore = true;

gameoverMessage = voice_gameover;
gameoverText = "GAME OVER";
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// SCORE
hud_Score = 0;
hud_Level = 0;
level_pulse = 0;

hud_chains = 0;
hud_chain_pulse = 0;
hud_chain_target = 0;
hud_chain_speed = 0;

hud_hypercube_blink = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string> Score = 0;
 multiplier = 0;

 level = 0;
    
 gridWidth = 6;
 gridYOffset = 3;
 gridHeight = 16;
 
 for(var i=0;i&lt;gridWidth;i++) {
 lockHeight[i] = -1;
    for(var j=0;j&lt;gridHeight;j++)
        grid[i,j] = noone;
    }
 
 scale = 79;
 
 defaultXPos = 3;
 
 state = state_gamestart;
 previousState = state;
 
 gameStartTimer = 120;
 gameStartScale = 0;
 gameStartScaleTarget = 0;
 
 pieceShift = 0;
 
 pieceX = 3;
 pieceY = gridYOffset-1;
 pieceHorRepeat = 0;
 pieceLockDelay = 30;
 pieceLockDelayBase = 30;
 pieceEntryDelay = 0;
 pieceEntryDelayBase = 7;
 ghostY = gridHeight-1;
 
 for(var i=0;i&lt;3;i++) {
  piecesFalling[i] = irandom(54) mod 6;
  piecesNext[i] = irandom(54) mod 6;
  piecePos[i] = i;
  }
  
 colorPallete[0] = $ff;
 colorPallete[1] = $88ff;
 colorPallete[2] = $ffff;
 colorPallete[3] = $00ff00;
 colorPallete[4] = $ff0000;
 colorPallete[5] = $ff00ff;
 colorPallete[6] = $ffffff; 
 colorPalleteI[0] = $ff0000;
 colorPalleteI[1] = $ff8800;
 colorPalleteI[2] = $ffff00;
 colorPalleteI[3] = $00ff00;
 colorPalleteI[4] = $0000ff;
 colorPalleteI[5] = $ff00ff;
 colorPalleteI[6] = $ffffff; 
 
 pauseTimer = 0;
 paused = false;
 
 hypercube = false;
 hypercubeNext = false;
 hypercubeThreshold = 100;
 
 movingGems = 0;
 
 bgFade = 0;
 bgFadeTarget = 0;

 gems  = 0;     // gems in a cascade
 cascades = 0;  // cascade count
 chains = 0;
 chainCount = false;
 gemsTotal = 0;
 
 gemsNextLevel = 40;
 gemsPerLevel = 40;
 
 gemAlpha = 1;

 breakdown = 0;
 
 y -= scale*gridYOffset;
 
 stackCheck = ds_stack_create();
 stackDelete = ds_stack_create();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>background_index[1] = choose(bg1,bg2,bg3,bg4,bg5,bg6,bg7,bg8,bg9,bg10,bg11);

gameover_explode = 120;

hud_levelbar = 0;

_stat_cascadeScore[level] = 0;
_stat_chainsScore[level] = 0;
_stat_colorScore[level] = 0;
_stat_matchesScore[level] = 0;
_stat_normalScore[level] = 0;
_stat_powerGems[level] = 0;
_stat_time[level] = 0;
_stat_moves[level] = 0;

for(i=0;i&lt;7;i++)
_stat_gemsMatched[level,i] = 0;

_stat_bestMove = 0;
_stat_longestChain = 0;
_stat_biggestCascade = 0;
_stat_mostColors = 0;
_stat_moveScore = 0;

_stat_timeTotal = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if hud_Score&lt;Score
hud_Score = ceil(lerp(hud_Score,Score,1/20));
else
hud_Score = floor(lerp(hud_Score,Score,1/20));

if hud_Level != level
{
    hud_Level = level;
    level_pulse = 1;
}
if level_pulse&gt;0
level_pulse -= 1/180;


if chains &gt; 0 {
 if hud_chains != chains {
    hud_chains = chains;
    hud_chain_pulse = 1+min(chains*0.05,0.33);
 }
 hud_chain_target = 1;
 hud_chain_pulse = max(lerp(hud_chain_pulse,1,0.05),1);
} else {
 if hud_chain_target==1 {hud_chain_target = 0; hud_chain_speed = -0.02;}

 hud_chain_speed += 0.000625;
 hud_chain_pulse = clamp(hud_chain_pulse+sign(hud_chain_target-hud_chain_pulse)*hud_chain_speed,0,1.33); 
}


/*p = instance_nearest(x,y,ui_score);
p.Score = Score;
p.Level = level;

p = instance_nearest(x,y,ui_nextpiece);
for(i=0;i&lt;3;i++){
 p.piece[i] =  piecesNext[i];
}

bgFade = lerp(bgFade,bgFadeTarget,0.04);

gemAlpha = lerp(gemAlpha,!paused,0.08)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>-1</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>paused</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (state != state_gameover) {
    _stat_time[level]++;
    _stat_timeTotal++;
    bgFade = lerp(bgFade,0,0.04);
} else {
    bgFade = lerp(bgFade,1,0.08);
}

hud_hypercube_blink = lerp(hud_hypercube_blink,0,0.04)   
gameStartScale = lerp(gameStartScale,gameStartScaleTarget,0.16);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if previousState != state {
    _stat_bestMove = max(_stat_bestMove,Score-_stat_moveScore);
    previousState = state;
    switch (state) {
        case state_play:
            failed = false;
            cleared = false;
            timedout = false;
            with obj_quest {
                if (grid == other.id) {
                    other.cleared = cleared;
                    other.failed = failed;
                    if (timer==0) {
                        other.timedout = true;
                    }
                }
            }
            if failed || cleared || timedout {
                state = state_gameover;
                if timedout {
                    gameoverMessage = voice_timeup;
                    gameoverText = "TIME UP";
                }
                if cleared {
                    gameoverMessage = voice_questcomplete;
                    gameoverText = 'QUEST COMPLETE'
                }
            }
            break;
        case state_crumble:
            _stat_moveScore = Score;
            break;
        case state_gameover: 
        
                audio_play_sound(gameoverMessage,0,0);
                bgFadeTarget = 1;
                t = instance_create(
                    x+gridWidth/2*scale,
                    y+gridYOffset*scale+(gridHeight-gridYOffset)/2*scale,
                    obj_gameover
                );
                t.text = gameoverText;
                t.timeTotal = string_time(_stat_timeTotal);
                t.bestMove = _stat_bestMove;
                t.cascade = _stat_biggestCascade;
                t.chain = _stat_longestChain;
                t.Score = Score;
                t.levels = level+1
                t._stat_cascadeScore = _stat_cascadeScore;
                t._stat_chainsScore = _stat_chainsScore;
                t._stat_colorScore = _stat_colorScore;
                t._stat_matchesScore = _stat_matchesScore;
                t._stat_normalScore = _stat_normalScore;
                
           with (obj_gem) {
                p = instance_create(x,y,obj_flyinggem);
                p.c = color;
                p.scale = other.scale;
                instance_destroy();
            }
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>state = state_play</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// levelling up

if gemsTotal &gt;= gemsNextLevel {

    level++;
    MOD_SetTempo(125+min(40*(level/20),70));    
    _stat_cascadeScore[level] = 0;
    _stat_chainsScore[level] = 0;
    _stat_colorScore[level] = 0;
    _stat_matchesScore[level] = 0;
    _stat_normalScore[level] = 0;
    _stat_powerGems[level] = 0;
    _stat_time[level] = 0;
    _stat_moves[level] = 0;
    
    for(i=0;i&lt;7;i++)
    _stat_gemsMatched[level,i] = 0;

    levelupPing = 90;
    gemsNextLevel = gemsTotal+gemsPerLevel;
    audio_play_sound(snd_levelup,0,0);
}

chainCount = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// controls
key_hor = - keyboard_check(vk_left) + keyboard_check(vk_right);
key_hor_pressed = -keyboard_check_pressed(vk_left) + keyboard_check_pressed(vk_right);
key_softdrop = keyboard_check(vk_down);
key_harddrop_pressed = keyboard_check_pressed(vk_up);
key_softdrop_pressed = keyboard_check_pressed(vk_down);
key_cycle = keyboard_check_pressed(vk_space);
key_cycle2 = keyboard_check_pressed(vk_shift);

if (key_hor != 0 and pieceHorRepeat&lt;=0) or key_hor_pressed != 0
{
    var t = pieceX+key_hor;
    if t&gt;=0 and t&lt;gridWidth and grid[t,pieceY] = noone {
        pieceX += key_hor;
    }
    pieceHorRepeat = 6;
}

for(ghostY=gridHeight-1;ghostY&gt;0;ghostY--) {
            if grid[pieceX,ghostY] == noone {
                break;
            }
        }
        
pieceX = clamp(pieceX,0,gridWidth-1);
pieceHorRepeat--;



    if key_cycle {pieceShift++; audio_play_sound(snd_swap,0,0);}
    if key_cycle2 {pieceShift--; audio_play_sound(snd_swap,0,0);}
    
    while pieceShift&lt;0 pieceShift+=3;
    while pieceShift&gt;=3 pieceShift-=3;
    
    for(i=0;i&lt;3;i++) {
        a = (pieceShift+i) mod 3; 
        piecePos[i] = lerp(piecePos[i],a,0.33);
        }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>spd = 1/max(2,25-level);
if key_softdrop {spd = 1/2;}

if pieceEntryDelay &lt;= 0
{
    pieceY += spd;
    
    if key_harddrop_pressed {
        for(i=pieceY;i&lt;=ghostY;i+=0.25) {
        var t = scale*0.15;
            effect_create_above(ef_spark,x+pieceX*scale+random_range(-t,t),y+i*scale,0,c_white)
            effect_create_above(ef_spark,x+(pieceX+1)*scale+random_range(-t,t),y+i*scale,0,c_white)
        }
        Score+= ceil(ghostY-pieceY)*2;
        _stat_normalScore[level]+= ceil(ghostY-pieceY)*2;
        pieceY = ghostY;
//        audio_play_sound(snd_harddrop,0,0);
        pieceLockDelay = 0;
    }
    
    if floor(pieceY)+1 &gt;= gridHeight or grid[pieceX,floor(pieceY)+1] != noone {
        pieceY = floor(pieceY);
        if (pieceLockDelay--&lt;=0) {
            _stat_moves[level]++;
            if (!hypercube) {
            for(i=0;i&lt;3;i++) {
              p = instance_create(x+scale*floor(pieceX),y+scale*floor(pieceY-wrap(pieceShift+i,3)),obj_gem);
              p.grid = id;
              p.color = piecesFalling[i];
              }
            } else {
              hypercube = false;
              pauseTimer = max(pauseTimer,6);
              g = noone;
              if floor(pieceY)+1 &lt; gridHeight {
                g = grid[pieceX,floor(pieceY)+1];
              }
             
              p = instance_create(x+scale*floor(pieceX),y+scale*floor(pieceY),obj_hypercube);
              p.size = scale;
              p.grid = id;
              if instance_exists(g) {
                p.color = g.color;
              }
              
            }
            if (!hypercubeNext) {        
            for(i=0;i&lt;3;i++) {
              piecesFalling[i] =  piecesNext[i];
              piecesNext[i] = irandom(54) mod 6;
            }} else {
                hypercubeNext = false;
                hypercube = true;
            }
            pieceEntryDelay = pieceEntryDelayBase;
            pieceLockDelay = pieceLockDelayBase;
            pieceX = defaultXPos;
            pieceY = gridYOffset-1;  
            pieceShift = 0;   
//            audio_play_sound(snd_lock,0,0);
            state = state_crumble;      
        }
    } else {
      if key_softdrop {_stat_normalScore[level]++; Score++;}
    }
} else {
pieceEntryDelay--;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>state = state_crumble</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if movingGems &lt;= 0 and pauseTimer &lt;= 0 {
    movingGems = 0;
    stackCheckAnything = ds_stack_empty(stackCheck)
    cellXmin = gridWidth; cellYmin = gridHeight;   
    cellXmax = 0; cellYmax = 0;       
    while !ds_stack_empty(stackCheck) {
        var checkedGem = ds_stack_pop(stackCheck);
        if instance_exists(checkedGem) {
            checkedGem.checked = true;
            cellXmin = min(cellXmin,checkedGem.gridX); cellYmin = min(cellYmin,checkedGem.gridY);
            cellXmax = max(cellXmax,checkedGem.gridX); cellYmax = max(cellYmax,checkedGem.gridY);
            match_check(checkedGem,grid,stackDelete,gridWidth,gridHeight);
        }
    }
    stackDeleteAnything = ds_stack_empty(stackDelete)
    gemsInMatch = 0;
    if !stackDeleteAnything {
        cascades++;
        pauseTimer=4;//45
        breakdown=1;
        for(i=0;i&lt;7;i++) c[i]=0;
            for(i=0;i&lt;gridWidth;i++){
                lockHeight[i] = -1;
            }
        colors = 0;
    }
    // Delete matched gems
    while !ds_stack_empty(stackDelete) {
        var deletedGem = ds_stack_pop(stackDelete);
        if instance_exists(deletedGem) and !deletedGem.invulnerable and !deletedGem.destroyed {
            // Mark the gem for destroy animation
            deletedGem.destroyed = true;
            // Add color to the counter
            if deletedGem.color&gt;=0
                c[deletedGem.color] += 1;
            // Mark the column for restacking    
            lockHeight[deletedGem.gridX] = max(lockHeight[deletedGem.gridX],deletedGem.gridY);
            // Free the spot
            grid[deletedGem.gridX,deletedGem.gridY] = noone;
            // Delete gem
            instance_destroy(deletedGem);
            // Add gem to counters
            gems++; gemsInMatch++; gemsTotal++;
        }
    }
    if !stackDeleteAnything {
        ct = c_white;
        
        // Count amount of colors in match
        for(i=0;i&lt;7;i++) { if c[i]&gt;0 {colors++; ct = colorPallete[i]} }
        if colors &gt; 0 {            
            // add score
            grid_scoring();
            
            // keep stats
            _stat_mostColors     = max(_stat_mostColors,colors);
            _stat_longestChain   = max(_stat_longestChain,chains);
            _stat_biggestCascade = max(_stat_biggestCascade,cascades);
            
            // if first match, advance chain counter
            if !chainCount { 
                if (++chains == 8) {
                    hypercubeNext = true;
                    audio_play_sound(snd_hypercube_awarded,0,false);
                    hud_hypercube_blink = 1;
                }; 
                chainCount = true; 
            }
            // if more than one color, play double match sound
            if colors &gt; 1  { 
                audio_play_sound(snd_double_match,0,0); 
            }
         
            // keep track of badges   
            grid_badgesCounting(); 
            
            // play match sound         
            p = grid_soundSelector();
            audio_play_sound(p,0,0);
            }    
        }
    else {
        // If checked gems but didn't found any matches
        if stackCheckAnything and !breakdown {
           // Return to play
           state = state_play;
           // If it isn't a cascade, then it break the chain bonus
           if !chainCount 
             chains = 0;
           // Else stop cascading  
           chainCount = false;
           
           // If default position is taken by something, trigger game over by lockdown
           if grid[defaultXPos,gridYOffset-1] != noone {
               state = state_gameover;
               audio_play_sound(snd_gameover_tremble,0,0);
           }
           
           // Else break cascade
           cascades = 0; 
           gems = 0; 
        }
    }
    
    // if gem fall delay passed and there are matching gems
    if pauseTimer&lt;=0 and breakdown {
        breakdown = false;
        // disconnect gems from grid to let them fall into new positions
        for(i=0;i&lt;gridWidth;i++){
            for(j=0;j&lt;=lockHeight[i];j++) {
                if instance_exists(grid[i,j]) { grid[i,j].gridLocked = false;     movingGems++;}
                grid[i,j] = noone;
            }
        }
    }
    
    // With all remaining gems, reset their state   
    with obj_gem { 
        if other.id = grid {
            checked = false; invulnerable = false; destroyed = false;
        } 
    }
}
pauseTimer--;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>state = state_gameover</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if gameover_explode-- == 0 {
    audio_play_sound(snd_gameover_explosion,0,0);
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>state = state_gamestart</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>gameStartTimer--

if gameStartTimer == 60 {
    audio_play_sound(voice_go,0,0);
    gameStartScaleTarget = 1;
}
if gameStartTimer == 1 {   
    gameStartScaleTarget = 0;
}
if gameStartTimer &lt;=0 {
    state = state_crumble;
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>-1</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>state = state_gameover</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>key_pause = keyboard_check_pressed(vk_enter);

if key_pause {
    paused = !paused; 
    if (paused) {
        instance_create(x+scale/2*gridWidth,y+scale*(gridYOffset+(gridHeight-gridYOffset)/2),obj_options)
    } else {
        instance_destroy(obj_options);
    }
}

var t = (gemsNextLevel-gemsTotal)/gemsPerLevel*100;

hud_levelbar = lerp(hud_levelbar,t,0.125);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="52">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with obj_gem { checked = false; invulnerable = false; destroyed = false; }
with obj_gem {ds_stack_push(other.stackDelete,id)};
Score = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="51">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with obj_gem { checked = false; invulnerable = false; destroyed = false; }
with obj_gem {ds_stack_push(other.stackCheck,id)};
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_alpha(bgFade*0.75);
draw_rectangle_colour(0,0,1920,1080,0,0,0,0,0);
draw_set_alpha(1);

draw_background_stretched(backgroundPlayer1,x,y+gridYOffset*scale,scale*gridWidth,scale*(gridHeight-gridYOffset));
c_rainbow = make_colour_hsv(current_time mod 1000/1000*255,255,255);

 if state==state_play and pieceEntryDelay&lt;=0 {
    if !hypercube {
    for(i=0;i&lt;3;i++) {
     draw_sprite_stretched_ext(spr_gem_ghost,piecesFalling[i],x+scale*pieceX,y+scale*(ghostY-wrap(pieceShift+i,3)),scale,scale,c_white,gemAlpha)     
     }
    for(i=0;i&lt;3;i++) {
     draw_sprite_stretched_ext(spr_gem_animated,piecesFalling[i]*20+(current_time mod 1000 / 1000 * 19.9),x+scale*pieceX,y+scale*(pieceY-piecePos[i]),scale,scale,c_white,gemAlpha)     
     }
    } else {
     draw_sprite_stretched_ext(spr_gem_ghost,6,x+scale*pieceX,y+scale*ghostY,scale,scale,c_rainbow,1);     
     draw_sprite_stretched(sprite1,current_time mod 4000 / 4000 * 59.9,x+scale*pieceX,y+scale*pieceY,scale,scale);
     draw_sprite_stretched(sprite2,current_time mod 4000 / 4000 * 59.9,x+scale*pieceX,y+scale*pieceY,scale,scale);     
    }
 }


 var pScale = (gridWidth+0.1)*scale/1056;
 var vScale = (gridWidth+0.5)*scale/1056;
 draw_set_halign(fa_left) draw_set_valign(fa_top); draw_set_font(font0);
 draw_text(0,30,'state:'+string(state));
  draw_set_halign(fa_center) draw_set_valign(fa_middle); draw_set_font(titleFont);
 if gameStartScale&gt;0.02 {
    draw_text_transformed_colour(x+scale/2*gridWidth+1,y+1+scale*(gridYOffset+(gridHeight-gridYOffset)/2),'GO!',gameStartScale,gameStartScale,0,0,0,0,0,0.75)
    draw_text_transformed_colour(x+scale/2*gridWidth,y+scale*(gridYOffset+(gridHeight-gridYOffset)/2),'GO!',gameStartScale,gameStartScale,0,c_yellow,c_yellow,c_yellow,c_yellow,1)
 }
    draw_text_transformed_colour(x+scale/2*gridWidth+1,y+1+scale*(gridYOffset+(gridHeight-gridYOffset)/2),'PAUSED',1,1,0,0,0,0,0,1-gemAlpha)
    draw_text_transformed_colour(x+scale/2*gridWidth,y+scale*(gridYOffset+(gridHeight-gridYOffset)/2),'PAUSED',1,1,0,c_aqua,c_aqua,c_aqua,c_aqua,1-gemAlpha)
    
draw_sprite_ext(spr_board_top,0,x+scale/2*gridWidth,y+gridYOffset*scale,pScale,pScale,0,c_white,1);
draw_healthbar(x+0.25*scale,y+gridHeight*scale,x+scale*(gridWidth-0.25),y+gridHeight*scale+40*vScale,100-hud_levelbar,$440044,c_blue,c_blue,0,1,0)

draw_sprite_ext(spr_board_bottom2,0,x+scale/2*gridWidth,y+gridHeight*scale,vScale,vScale,0,c_white,1);

draw_set_halign(fa_center)draw_set_valign(fa_middle)draw_set_font(font2)
draw_text_transformed_colour(x+gridWidth/2*scale,y+gridHeight*scale+vScale*20,string(gemsTotal)+' / '+string(gemsNextLevel),vScale,vScale,0,c_white,c_white,c_white,c_white,1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="114">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>hypercubeNext = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
