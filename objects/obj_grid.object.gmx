<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite8</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string> Score = 0;
 multiplier = 0;

 level = 0;
    
 gridWidth = 6;
 gridYOffset = 3;
 gridHeight = 16;
 
 for(var i=0;i&lt;gridWidth;i++) 
    for(var j=0;j&lt;gridHeight;j++)
        grid[i,j] = noone;
 
 scale = 79;
 
 defaultXPos = 3;
 
 state = state_crumble;
 previousState = state;
 
 pieceShift = 0;
 
 pieceX = 3;
 pieceY = gridYOffset-1;
 pieceHorRepeat = 0;
 pieceLockDelay = 30;
 pieceLockDelayBase = 30;
 pieceEntryDelay = 0;
 pieceEntryDelayBase = 7;
 ghostY = gridHeight-1;
 
 for(var i=0;i&lt;3;i++) {
  piecesFalling[i] = irandom(54) mod 6;
  piecesNext[i] = irandom(54) mod 6;
  piecePos[i] = i;
  }
  
 colorPallete[0] = $ff;
 colorPallete[1] = $88ff;
 colorPallete[2] = $ffff;
 colorPallete[3] = $00ff00;
 colorPallete[4] = $ff0000;
 colorPallete[5] = $ff00ff;
 colorPallete[6] = $ffffff; 
 
 pauseTimer = 0;
 paused = false;
 
 hypercube = false;
 hypercubeNext = false;
 hypercubeThreshold = 100;
 
 movingGems = 0;

 gems  = 0;     // gems in a cascade
 cascades = 0;  // cascade count
 chains = 0;
 chainCount = false;
 gemsTotal = 0;
 
 gemsNextLevel = 40;
 gemsPerLevel = 40;

 breakdown = 0;
 
 y -= scale*gridYOffset;
 
 stackCheck = ds_stack_create();
 stackDelete = ds_stack_create();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>gameover_explode = 120;

hud_levelbar = 0;

_stat_cascadeScore[level] = 0;
_stat_chainsScore[level] = 0;
_stat_colorScore[level] = 0;
_stat_matchesScore[level] = 0;
_stat_normalScore[level] = 0;
_stat_powerGems[level] = 0;
_stat_time[level] = 0;
_stat_moves[level] = 0;

for(i=0;i&lt;7;i++)
_stat_gemsMatched[level,i] = 0;

_stat_bestMove = 0;
_stat_longestChain = 0;
_stat_biggestCascade = 0;
_stat_mostColors = 0;


_stat_timeTotal = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>p = instance_nearest(x,y,ui_score);
p.Score = Score;
p.Level = level;

p = instance_nearest(x,y,ui_nextpiece);
for(i=0;i&lt;3;i++){
 p.piece[i] =  piecesNext[i];
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>-1</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>paused</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (state != state_gameover) {
    _stat_time[level]++;
    _stat_timeTotal++;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if previousState != state {
    previousState = state;
    
    switch (state) {
        case state_gameover: 
            
           with (obj_gem) {
                p = instance_create(x,y,obj_flyinggem);
                p.c = color;
                p.scale = other.scale;
                instance_destroy();
            }
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>state = state_play</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// levelling up

if gemsTotal &gt; gemsNextLevel {

    level++;
    
    _stat_cascadeScore[level] = 0;
    _stat_chainsScore[level] = 0;
    _stat_colorScore[level] = 0;
    _stat_matchesScore[level] = 0;
    _stat_normalScore[level] = 0;
    _stat_powerGems[level] = 0;
    _stat_time[level] = 0;
    _stat_moves[level] = 0;
    
    for(i=0;i&lt;7;i++)
    _stat_gemsMatched[level,i] = 0;

    levelupPing = 90;
    gemsNextLevel = gemsTotal+gemsPerLevel;
    audio_play_sound(snd_levelup,0,0);
}

chainCount = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// controls
key_hor = - keyboard_check(vk_left) + keyboard_check(vk_right);
key_hor_pressed = -keyboard_check_pressed(vk_left) + keyboard_check_pressed(vk_right);
key_softdrop = keyboard_check(vk_down);
key_harddrop_pressed = keyboard_check_pressed(vk_up);
key_softdrop_pressed = keyboard_check_pressed(vk_down);
key_cycle = keyboard_check_pressed(vk_space);
key_cycle2 = keyboard_check_pressed(vk_shift);

if (key_hor != 0 and pieceHorRepeat&lt;=0) or key_hor_pressed != 0
{
    var t = pieceX+key_hor;
    if t&gt;=0 and t&lt;gridWidth and grid[t,pieceY] = noone {
        pieceX += key_hor;
    }
    pieceHorRepeat = 6;
}

for(ghostY=gridHeight-1;ghostY&gt;0;ghostY--) {
            if grid[pieceX,ghostY] == noone {
                break;
            }
        }
        
pieceX = clamp(pieceX,0,gridWidth-1);
pieceHorRepeat--;



    if key_cycle {pieceShift++; audio_play_sound(snd_swap,0,0);}
    if key_cycle2 {pieceShift--; audio_play_sound(snd_swap,0,0);}
    
    while pieceShift&lt;0 pieceShift+=3;
    while pieceShift&gt;=3 pieceShift-=3;
    
    for(i=0;i&lt;3;i++) {
        a = (pieceShift+i) mod 3; 
        piecePos[i] = lerp(piecePos[i],a,0.33);
        }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>spd = 1/max(2,50-level);
if key_softdrop {spd = 1/2;}

if pieceEntryDelay &lt;= 0
{
    pieceY += spd;
    
    if key_harddrop_pressed {
        for(i=pieceY;i&lt;=ghostY;i+=0.25) {
        var t = scale*0.15;
            effect_create_above(ef_spark,x+pieceX*scale+random_range(-t,t),y+i*scale,0,c_white)
            effect_create_above(ef_spark,x+(pieceX+1)*scale+random_range(-t,t),y+i*scale,0,c_white)
        }
        Score+= ceil(ghostY-pieceY)*2;
        pieceY = ghostY;
//        audio_play_sound(snd_harddrop,0,0);
        pieceLockDelay = 0;
    }
    
    if floor(pieceY)+1 &gt;= gridHeight or grid[pieceX,floor(pieceY)+1] != noone {
        pieceY = floor(pieceY);
        if (pieceLockDelay--&lt;=0) {
            _stat_moves[level]++;
            for(i=0;i&lt;3;i++) {
              p = instance_create(x+scale*floor(pieceX),y+scale*floor(pieceY-wrap(pieceShift+i,3)),obj_gem);
              p.color = piecesFalling[i];
              }
            for(i=0;i&lt;3;i++) {
              piecesFalling[i] =  piecesNext[i];
              piecesNext[i] = irandom(54) mod 6;
            }
            pieceEntryDelay = pieceEntryDelayBase;
            pieceLockDelay = pieceLockDelayBase;
            pieceX = defaultXPos;
            pieceY = gridYOffset-1;  
            pieceShift = 0;   
//            audio_play_sound(snd_lock,0,0);
            state = state_crumble;      
        }
    } else {
      if key_softdrop Score++;
    }
} else {
pieceEntryDelay--;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>state = state_crumble</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if movingGems &lt;= 0 and pauseTimer &lt;= 0 {
    movingGems = 0;
    stackCheckAnything = ds_stack_empty(stackCheck)
    cellXmin = gridWidth; cellYmin = gridHeight;   
    cellXmax = 0; cellYmax = 0;       
    while !ds_stack_empty(stackCheck) {
        var checkedGem = ds_stack_pop(stackCheck);
        if instance_exists(checkedGem) {
            checkedGem.checked = true;
            cellXmin = min(cellXmin,checkedGem.gridX); cellYmin = min(cellYmin,checkedGem.gridY);
            cellXmax = max(cellXmax,checkedGem.gridX); cellYmax = max(cellYmax,checkedGem.gridY);
            match_check(checkedGem,grid,stackDelete,gridWidth,gridHeight);
        }
    }
    stackDeleteAnything = ds_stack_empty(stackDelete)
    gemsInMatch = 0;
    if !stackDeleteAnything {
        cascades++;
        pauseTimer=4;//45
        breakdown=1;
        for(i=0;i&lt;7;i++) c[i]=0;
            for(i=0;i&lt;gridWidth;i++){
                lockHeight[i] = -1;
            }
        colors = 0;
    }

    while !ds_stack_empty(stackDelete) {
        var deletedGem = ds_stack_pop(stackDelete);
        if instance_exists(deletedGem) and !deletedGem.invulnerable and !deletedGem.destroyed {
            if deletedGem.color&gt;=0
            c[deletedGem.color] += 1;
            lockHeight[deletedGem.gridX] = max(lockHeight[deletedGem.gridX],deletedGem.gridY);
            grid[deletedGem.gridX,deletedGem.gridY] = noone;
            instance_destroy(deletedGem);
            gems++; gemsInMatch++; gemsTotal++;
        }
    }
    if !stackDeleteAnything {
        var ct = c_white;
        for(i=0;i&lt;7;i++) {
            if c[i]&gt;0 {colors++; ct = colorPallete[i]}
            }
        if colors &gt; 0 {            
            totalMultiplier = (chains/3*(chainCount==false)) + (colors-1) + (cascades-1) + (gemsInMatch - 3);
            sc = (30 + 10*chains*(chainCount==false)) * colors * cascades * (gemsInMatch - 2);            
            Score += sc * (level+1) * (multiplier + 1);
            t = instance_create(x+(mean(cellXmin,cellXmax)+0.5)*scale,y+(mean(cellYmin,cellYmax)+0.5)*scale,tooltip_score);
                t.c = ct;
                t.text = sc* (level+1) * (multiplier + 1);
                t.rainbow = colors &gt; 3 or colors*cascades*(gemsInMatch - 2) &gt; 8
                
            if (totalMultiplier &gt; 0) {
                show_debug_message('multiplier');
                show_debug_message(totalMultiplier);
                var a = (cascades-1)             / totalMultiplier;
                var b = (colors-1)               / totalMultiplier;
                var c = (chains/3*(!chainCount)) / totalMultiplier;
                var d = (gemsInMatch - 3)        / totalMultiplier;
                
                _stat_cascadeScore[level] += (sc-30) * a * (multiplier + 1) * (level+1);
                _stat_chainsScore[level]  += (sc-30) * c * (multiplier + 1) * (level+1);
                _stat_colorScore[level]   += (sc-30) * b * (multiplier + 1) * (level+1);
                _stat_matchesScore[level] += (sc-30) * d * (multiplier + 1) * (level+1);
            }

            if !chainCount {chains++; chainCount = true; }
            if colors &gt; 1  {audio_play_sound(snd_double_match,0,0);}
            
            switch cascades {
            case 0: case 1:
                switch chains {
                case 0: p = snd_match_1; break;
                case 1: p = snd_match_1; break;
                case 2: p = snd_speed2; break;
                case 3: p = snd_speed3; break;
                case 4: p = snd_speed4; break;
                case 5: p = snd_speed5; break;
                case 6: p = snd_speed6; break;
                case 7: p = snd_speed7; break;
                case 8: p = snd_speed8; break;
                default: p = snd_speed9; break;
                }            
            break;
            case 2: p = snd_match_2; break;
            case 3: p = snd_match_3; break;
            case 4: p = snd_match_4; break;                        
            case 5: p = snd_match_5; break;        
            default: p = snd_match_6; break;
            }
            
            
            
            _stat_normalScore[level]  += 30 * (multiplier + 1) * (level+1);
            _stat_mostColors     = max(_stat_mostColors,colors);
            _stat_longestChain   = max(_stat_longestChain,chains);
            _stat_biggestCascade = max(_stat_biggestCascade,cascades);
            
            audio_play_sound(p,0,0);
            }    
        }
    else {
        if stackCheckAnything and !breakdown {
           state = state_play;
           if !chainCount chains = 0;
           chainCount = false;
           if grid[defaultXPos,gridYOffset-1] != noone {
               state = state_gameover;
               audio_play_sound(snd_gameover_tremble,0,0);
           }
           cascades = 0; 
           gems = 0; 
        }
    }
    
    if pauseTimer&lt;=0 and breakdown {
        breakdown = false;
        for(i=0;i&lt;gridWidth;i++){
            for(j=0;j&lt;=lockHeight[i];j++) {
                if instance_exists(grid[i,j]) { grid[i,j].gridLocked = false;     movingGems++;}
                grid[i,j] = noone;
            }
        }
    }
    
    with obj_gem { checked = false; invulnerable = false; destroyed = false; }
}
pauseTimer--;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>408</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>state = state_gameover</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if gameover_explode-- == 0 {
    audio_play_sound(snd_gameover_explosion,0,0);
    t = instance_create(
                    x+gridWidth/2*scale,
                    y+gridYOffset*scale+(gridHeight-gridYOffset)/2*scale,
                    obj_gameover
                );
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>key_pause = keyboard_check_pressed(vk_enter);

if key_pause paused = !paused;

var t = (gemsNextLevel-gemsTotal)/gemsPerLevel*100;

hud_levelbar = lerp(hud_levelbar,t,0.125);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="52">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with obj_gem { checked = false; invulnerable = false; destroyed = false; }
with obj_gem {ds_stack_push(other.stackDelete,id)};
Score = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="51">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with obj_gem { checked = false; invulnerable = false; destroyed = false; }
with obj_gem {ds_stack_push(other.stackCheck,id)};
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string></string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_background_stretched(backgroundPlayer1,x,y+gridYOffset*scale,scale*gridWidth,scale*(gridHeight-gridYOffset));
c_rainbow = make_colour_hsv(current_time mod 1000 / 1000 * 255,255,255);

 if state==state_play and pieceEntryDelay&lt;=0 {
    if !hypercube {
    for(i=0;i&lt;3;i++) {
     draw_sprite_stretched(spr_gem_ghost,piecesFalling[i],x+scale*pieceX,y+scale*(ghostY-wrap(pieceShift+i,3)),scale,scale)     
     }
    for(i=0;i&lt;3;i++) {
     draw_sprite_stretched(spr_gem_animated,piecesFalling[i]*20+(current_time mod 1000 / 1000 * 19.9),x+scale*pieceX,y+scale*(pieceY-piecePos[i]),scale,scale)     
     }
    } else {
     draw_sprite_stretched_ext(spr_gem_ghost,7,x+scale*pieceX,y+scale*ghostY,scale,scale,c_rainbow,1);     
     draw_sprite_stretched(sprite1,piecesFalling[i],x+scale*pieceX,y+scale*pieceY,scale,scale);
     draw_sprite_stretched(sprite2,piecesFalling[i],x+scale*pieceX,y+scale*pieceY,scale,scale);     
    }
 }

 var pScale = (gridWidth+0.1)*scale/1056;
 var vScale = (gridWidth+0.5)*scale/1056;
 
 t = 'cascade score: ' + string(_stat_cascadeScore[level]) + '#';
 t += 'matches score: ' + string(_stat_chainsScore[level]) + '#';
 t += 'match size score: ' + string(_stat_matchesScore[level]) + '#'; 
t += 'color score: ' + string(_stat_colorScore[level]) + '#';
t += 'score: ' + string(_stat_normalScore[level]) + '#';
t += 'power gems score: ' + string(_stat_powerGems[level]) + '#';
t += 'time taken: ' + string_time(_stat_time[level]) + '#';
t += 'moves: ' + string(_stat_moves[level]) + '#';

t += 'best move: ' + string(_stat_bestMove) + '#';
t += 'longest chain: ' + string(_stat_longestChain) + '#';
t += 'biggest cascade: ' + string(_stat_biggestCascade) + '#';
t += 'most colors: ' + string(_stat_mostColors) + '#';

 draw_set_halign(fa_left) draw_set_valign(fa_bottom) draw_set_font(font0)
 draw_text(x+(gridWidth+0.25)*scale,y+gridHeight*scale,t);
 
 
draw_sprite_ext(spr_board_top,0,x+scale/2*gridWidth,y+gridYOffset*scale,pScale,pScale,0,c_white,1);
draw_healthbar(x+0.25*scale,y+gridHeight*scale,x+scale*(gridWidth-0.25),y+gridHeight*scale+40*vScale,100-hud_levelbar,$440044,c_blue,c_blue,0,1,0)

draw_sprite_ext(spr_board_bottom2,0,x+scale/2*gridWidth,y+gridHeight*scale,vScale,vScale,0,c_white,1);

draw_set_halign(fa_center)draw_set_valign(fa_middle)draw_set_font(font2)
draw_text_transformed_colour(x+gridWidth/2*scale,y+gridHeight*scale+vScale*20,string(gemsTotal)+' / '+string(gemsNextLevel),vScale,vScale,0,c_white,c_white,c_white,c_white,1);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
